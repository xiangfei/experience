##  Redraiment的走法

[链接：牛客网](https://www.nowcoder.com/questionTerminal/69ef2267aafd4d52b250a272fd27052c)

## 描述

- Redraiment是走梅花桩的高手。Redraiment可以选择任意一个起点，从前到后，但只能从低处往高处的桩子走。他希望走的步数最多，你能替Redraiment研究他最多走的步数吗？


- 数据范围：每组数据长度满足 1≤n≤200  ， 数据大小满足1≤val≤350  

  

## 输入描述：
- 数据共2行，第1行先输入数组的个数，第2行再输入梅花桩的高度




## 输出描述：
- 输出一个结果




## 示例1

```bash
输入： 6
2 5 1 5 4 5 


输出： 3

6个点的高度各为 2 5 1 5 4 5
如从第1格开始走,最多为3步, 2 4 5 ，下标分别是 1 5 6
从第2格开始走,最多只有1步,5
而从第3格开始走最多有3步,1 4 5， 下标分别是 3 5 6
从第5格开始走最多有2步,4 5， 下标分别是 5 6
所以这个结果是3。    

```

## 解析

[参考文章](http://wjhsh.net/goldsunshine-p-13221674.html)


### 动态规划解题思路
使用动态规划解题，需要题目符合动态规划的解决思路。动态规划解题思路是：

将大的问题拆解成小一点问题，小问题和大问题的解决思路是类似的
小问题之间的关系能完成大问题的最优解
通常拆解问题的方法有两种，一种是二分法，把数组拆成两个。第二种是将将数组逐个递减，拆解成多个小数组。对于本体来说，第二种方式比较适合。

小规模问题和大规模问题之间有某种联系，这种联系就是动态转移方程。通过小规模问题的解决，能够解决大规模问题，直到解决最终的问题。
题目是要求数组 [2,5,1,5,4,5]中最长的升序数组。可以按照动态规划的思路，将大问题拆解成小问题。求6个元素的最长升序，可以拆解成求5个，同理求5个元素的，可以拆解成求4个。最后一直到1个。

[2,5,1,5,4,5]
[2,5,1,5,4]
[2,5,1,5]
[2,5,1]
[2,5]  
[2]  
各个小问题之间有一定联系，通过找到小问题之间的联系，求出最优解。小问题之间的联系就是状态转移方程。

### 建立数学模型
求最多的步数，但不知道是从哪一步开始算最多。所以就创建一个数组dp，数组dp中存储从第一个梅花桩到当前梅花桩的步数。因为求的步数，最少也走一步，所以dp的初始值就是

dp = [1,1,1,1,...1]
### 状态转移方程
当前梅花桩最多的步数，就是拿当前梅花桩逐个和前面的梅花桩比较，当前梅花桩高就比较是比当前小的梅花桩的最大值+1大 还是 该梅花桩本身的值大。通俗来说就是找出梅花桩数值小的。即：

dp[j] + 1 大 还是 dp[i] 大


`下标为0时，dp数组`


| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  1 |  1 |  1 |  1 |  1 |


`下标为1时，dp数组。`
- 因为 5 比 2大，所有，dp[0] + 1 > dp[1],所以dp[1]=1+1=2


| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  2 |  1 |  1 |  1 |  1 |

`下标为2时，dp数组：`
- 1 < 5, 1< 2，所以dp数组不变，dp[2] = 1

| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  2 |  1 |  1 |  1 |  1 |


`下标为3时，dp数组：`
- 5 > 1,所以dp[3] = max(dp[2]+1,dp[3]) = max(2,1) = 2
- 同时，5 > 2 ,所以dp[3] = max(2,dp[0]+1) = max(2,2) = 2。
- 所以dp[3] = 2

| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  2 |  1 |  2 |  1 |  1 |

`下标为4时，dp数组：`
- 4 > 1 ,dp[4] = max(dp[4],dp[2]+1) = max(1,2) = 2

| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  2 |  1 |  2 |  2 |  1 |

`下标为5时，dp数组：`
- 5 > 4 ,dp[5] = max(dp[5],dp[4]+1) = max(1,3) = 3
- 5 > 1 ,dp[5] = max(3,1) = 3
- 5 > 2 ,dp[5] = max(3,1) = 3


| 2 | 5 | 1 |  5 |  4 |  5 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|1  |  2 |  1 |  2 |  2 |  3 |


边界值
边界值很清晰就是第一个梅花桩就一步，也就是dp[1,x,x,x,x,x]

## ruby

```ruby 

input = ""

while (line = STDIN.gets)
    input = line.chomp
end

def  reverse  string
    result = []
    string.split("\s+").each do |sub|
        result << sub.reverse
    end
    puts result.reverse.join(" ")
end
reverse input

```